<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><title>Anroid Binder机制 | Edwin Here</title><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Anroid Binder机制" /><meta name="author" content="Edwin" /><meta property="og:locale" content="en_US" /><meta name="description" content="一. 前言" /><meta property="og:description" content="一. 前言" /><link rel="canonical" href="https://edwin1122.github.io/posts/Android-Binder/" /><meta property="og:url" content="https://edwin1122.github.io/posts/Android-Binder/" /><meta property="og:site_name" content="Edwin Here" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-17T10:50:43+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Anroid Binder机制" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Edwin" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"一. 前言","headline":"Anroid Binder机制","dateModified":"2021-03-18T09:37:45+08:00","datePublished":"2021-03-17T10:50:43+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://edwin1122.github.io/posts/Android-Binder/"},"url":"https://edwin1122.github.io/posts/Android-Binder/","author":{"@type":"Person","name":"Edwin"},"@type":"BlogPosting","@context":"https://schema.org"}</script><meta name="baidu-site-verification" content="codeva-5ON7F89Tlh" /><title>Anroid Binder机制 | Edwin Here</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-WSKNYL2CGL"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-WSKNYL2CGL'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/ms-icon-310x310.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Edwin Here</a></div><div class="site-subtitle font-italic">Here are my voices</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/Edwin1122" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['edwinluo1122','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Anroid Binder机制</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Anroid Binder机制</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 17, 2021, 10:50 AM +0800" > Mar 17, 2021 <i class="unloaded">2021-03-17T10:50:43+08:00</i> </span> by <span class="author"> Edwin </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Mar 18, 2021, 9:37 AM +0800" > Mar 18, 2021 <i class="unloaded">2021-03-18T09:37:45+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4308 words">23 min</span></div></div><div class="post-content"><h2 id="一-前言">一. 前言</h2><p>Android 的 Binder 机制, 是作为 Android 进阶学习中一个必学的知识点。 之前, 通过学习 《Android 开发艺术探索》以及 网上的一些博客, 大致了解 Android Binder 机制的过程, 自以为已掌握 Binder 机制的大致过程, 写下博客 Android—-IPC机制（Binder） , 但是实际上只是了解了皮毛，没有深入整个流程，于是重新学习，将新的体会记录成这篇 进阶篇。</p><p>阅读这篇文章之前需要具备基本的 Binder 机制的流程, 具体可通过这些博客学习</p><p><a href="https://blog.csdn.net/m0_38089373/article/details/81206893">Android—-IPC机制（Binder）</a></p><p><a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a></p><p><a href="https://www.jianshu.com/p/4ee3fd07da14">图文详解 Android Binder跨进程通信的原理</a></p><p>手动实现 Binder 的通信, 不依靠 AIDL 自动生成。</p><h2 id="二-跨进程">二. 跨进程</h2><h3 id="一-用户空间内核空间">(一). 用户空间/内核空间</h3><p>内核空间是 Linux 系统中内核的运行空间, 在内核空间可以随意访问系统的资源, 系统内核对资源进行同一的管理。 用户空间是每个用户进程运行的空间, 这个空间是进程独有的, 不能和其他进程进行内存共享, 主要是用于保存进程中的数据等, 由于可能存在有恶意的用户进程对系统进行破坏, 且系统资源是宝贵的, 这就需要保证系统的安全, 所以一个进程的用户空间不能直接访问系统资源。 那么一个用户空间如何访问系统资源呢？</p><p>通过内核提供的接口, 向内核发出指令, 然后交由内核去访问系统资源。</p><p>大致情况如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://yishengma.github.io/2019/01/24/Android-Binder%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/1240" alt="alt" /></p><h3 id="二-binder-驱动">(二). Binder 驱动</h3><p>虽然两个进程的用户空间互不共享, 但是一个进程除了有用户空间, 还有内核空间, 且内核空间是共有的, 所以两个进程想要进行通信, 那么就可以通过一个在内核空间的中介进行数据的交互，这个中介就是 Binder 驱动。</p><p>Binder 驱动是 Android 在 Linux 内核上添加的一个内核模块，作为内核的一部分在内核空间上运行里运行, 两个进程通过这个在内核空间运行的 Binder 驱动就可以进行通信。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://yishengma.github.io/2019/01/24/Android-Binder%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/12401" alt="alt" /></p><h3 id="三-内核启动">(三). 内核启动</h3><p>Binder 驱动是运行在内核空间的, 在内核启动的时候 就会将 Binder 注册成 misc device 类型的驱动, 也就是内核驱动。</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre>
<span class="kd">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">binder_init</span><span class="o">(</span><span class="kt">void</span><span class="o">)</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="o">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">device_name</span><span class="o">,</span> <span class="o">*</span><span class="n">device_names</span><span class="o">;</span>
    <span class="n">struct</span> <span class="n">binder_device</span> <span class="o">*</span><span class="n">device</span><span class="o">;</span>
    <span class="n">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">tmp</span><span class="o">;</span>
    
    <span class="k">while</span> <span class="o">((</span><span class="n">device_name</span> <span class="o">=</span> <span class="n">strsep</span><span class="o">(&amp;</span><span class="n">device_names</span><span class="o">,</span> <span class="s">","</span><span class="o">)))</span> <span class="o">{</span>
        <span class="c1">//初始化 Binder 设备</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">init_binder_device</span><span class="o">(</span><span class="n">device_name</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">ret</span><span class="o">)</span>
            <span class="k">goto</span> <span class="n">err_init_binder_device_failed</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
<span class="kd">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_binder_device</span><span class="o">(</span><span class="kd">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="o">)</span>
<span class="o">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="o">;</span>
    <span class="n">struct</span> <span class="n">binder_device</span> <span class="o">*</span><span class="n">binder_device</span><span class="o">;</span>
    
    <span class="c1">//1.为 Binder 设备开辟空间</span>
    <span class="n">binder_device</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="o">(</span><span class="n">sizeof</span><span class="o">(*</span><span class="n">binder_device</span><span class="o">),</span> <span class="no">GFP_KERNEL</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">binder_device</span><span class="o">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="no">ENOMEM</span><span class="o">;</span>
    <span class="c1">//2.初始化 Binder </span>
    <span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">miscdev</span><span class="o">.</span><span class="na">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">binder_fops</span><span class="o">;</span>
    <span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">miscdev</span><span class="o">.</span><span class="na">minor</span> <span class="o">=</span> <span class="no">MISC_DYNAMIC_MINOR</span><span class="o">;</span>
    <span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">miscdev</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>

    <span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">context</span><span class="o">.</span><span class="na">binder_context_mgr_uid</span> <span class="o">=</span> <span class="no">INVALID_UID</span><span class="o">;</span>
    <span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">context</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">//2.注册 Binder  设备</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">misc_register</span><span class="o">(&amp;</span><span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">miscdev</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">kfree</span><span class="o">(</span><span class="n">binder_device</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">hlist_add_head</span><span class="o">(&amp;</span><span class="n">binder_device</span><span class="o">-&gt;</span><span class="n">hlist</span><span class="o">,</span> <span class="o">&amp;</span><span class="n">binder_devices</span><span class="o">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="o">;</span>
<span class="o">}</span>

</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://yishengma.github.io/2019/01/24/Android-Binder%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/12402" alt="alt" /></p><h2 id="三-servicemanager">三. ServiceManager</h2><p>有大致了解过的 Binder 的人都知道 Binder 机制涉及到四个对象</p><p>客户端 服务端 Binder 驱动 ServiceManager 前三个相信大家都清楚是什么, 至于第四个 ServiceManager, 从名字上就可以看出, 它的作用就是对服务端进行管理, 进程间的通信时一个常见的功能, 每个进程都可以作为客户端或服务端通过 Binder 驱动参与进程间的通信, 而且通信的前提就是找到通信的另一方, 并建立联系, ServiceManager 的作用就在于此，其记录了所有的服务端, 当一个客户端想要和服务端进行通信的时候，首先就会去 ServiceManager 找到对应的服务端。这好比打电话, Binder 驱动就是信号基站, 而 ServiceManager 就是一个通信录，进行 A 要和 进程 B 进行通信, 首先就要去 通信录找到进程 B 的电话号码是多少, 然后就可通过这个电话号码, 将数据通过信号基站传递给进程 B ，这就完成了进程通信。</p><p>但是 ServiceManager 本身也是一个进程, 这是一个 native 进程, 客户端获取电话号码的过程也本应该是一个跨进程的通信(实际上并没有), 那么客户端是如何首先获取 ServiceManager 的对应的 Binder 引用的呢?</p><p>这就是本篇文章要解决的第一个问题。</p><h3 id="一-servicemanager-的启动">(一). ServiceManager 的启动</h3><p>ServiceManager 是一个 native 进程, 其源码自然是 C/C++ , 但是不用担心, 这里只关注一些重要的地方, 通过函数的名字就可以看出其作用。</p><p>1.init 进程 在 Android 系统中 init 进程是系统启动的第一个进程, 在内核启动后就会启动 init 进程 , 它启动后就会去解析 init.c 这个文件，然后启动其他的 native 进程, 而 ServiceManager 作为一个 native 进程, 自然也是由它启动的。</p><p>在解析 init.rc 文件的时候去启动 servicemanager.rc</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>
service servicemanager /system/bin/servicemanager
    class core animation
    user system
    group system readproc
    critical
    onrestart restart healthd
    onrestart restart zygote
    onrestart restart audioserver
    onrestart restart media
    onrestart restart surfaceflinger
    onrestart restart inputflinger
    onrestart restart drm
    onrestart restart cameraserver
    onrestart restart keystore
    onrestart restart gatekeeperd
    writepid /dev/cpuset/system-background/tasks
    shutdown critical

</pre></table></code></div></div><p>2.servicemanager 的启动 servicemanager 的启动 的 启动从 servicemanager.c 文件中的 main 方法开始的</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>
<span class="c1">// native\native\cmds\servicemanager\servicemanager.c</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>
    
    <span class="c1">// 1.打开 Binder 驱动</span>
    <span class="c1">//并设置 servicemanager 进行地址映射的大小为  128 KB </span>
    <span class="n">bs</span> <span class="o">=</span> <span class="n">binder_open</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>
    
    <span class="c1">// 2.将 servicemanager 驱动设置为唯一的管理者，也就是系统内核只有一个servicemanager</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">binder_become_context_manager</span><span class="p">(</span><span class="n">bs</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ALOGE</span><span class="p">(</span><span class="s">"cannot become context manager (%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//3.启动循环，不断处理客户端的请求</span>
    <span class="n">binder_loop</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">svcmgr_handler</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>(1).binder_open</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre> <span class="c1">// native\native\cmds\servicemanager\binder.c</span>
 
<span class="k">struct</span> <span class="n">binder_state</span> <span class="o">*</span><span class="nf">binder_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">driver</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">mapsize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">binder_version</span> <span class="n">vers</span><span class="p">;</span>

    <span class="n">bs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bs</span><span class="p">));</span>
   
    <span class="c1">//进入系统内核 打开 Binder 设备</span>
    <span class="n">bs</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">driver</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
   
    <span class="c1">//地址映射</span>
    <span class="n">bs</span><span class="o">-&gt;</span><span class="n">mapsize</span> <span class="o">=</span> <span class="n">mapsize</span><span class="p">;</span>
    <span class="n">bs</span><span class="o">-&gt;</span><span class="n">mapped</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">mapsize</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">bs</span><span class="p">;</span>

</pre></table></code></div></div><p>系统内核打开 Binder 设备</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">binder_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">nodp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">binder_device</span> <span class="o">*</span><span class="n">binder_dev</span><span class="p">;</span>

    <span class="c1">//为当前进程 创建一个 proc 结构体</span>
    <span class="c1">//这里就是为 ServiceManager 创建一个结构体</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">proc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="c1">//初始化结构体的 todo 队列</span>
    
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">todo</span><span class="p">);</span>  
    <span class="c1">//初始化结构体的 wait 队列</span>
    <span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
    
    <span class="c1">//加锁</span>
    <span class="n">binder_lock</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>

    <span class="n">binder_stats_created</span><span class="p">(</span><span class="n">BINDER_STAT_PROC</span><span class="p">);</span>
    <span class="c1">//将当前进程,也就是  ServiceManager 的结构体添加到 Binder 的一个全局队列中</span>
    <span class="n">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">proc_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">binder_procs</span><span class="p">);</span>
    <span class="n">proc</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">delivered_death</span><span class="p">);</span>
    <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>

   <span class="c1">//释放锁</span>
    <span class="n">binder_unlock</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>首先我们需要知道的是每一个作为服务端的进程, 都对应在 Binder 驱动中的一个节点 todo 队列保存的是请求的事务，如果一个客户端发起一个请求, 那么就会向 todo 队列添加一个事务。 wait 队列, 将客户端发起请求后等待响应添加到 wait 等待队列, 待服务端执行完后就唤醒。 由于发起 Binder 线程的情况有很多但是每个进程只创建一个对应的结构体添加到链表里，因此就需要加锁。</p><p>ServiceManager 注册后的情况就是如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://yishengma.github.io/2019/01/24/Android-Binder%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/12403" alt="alt" /></p><p>(2)将 servicemanager 驱动设置为唯一的管理者, 并设置为 0 号 handler 前面说过 servicemanager 管理者其他服务端, 客户端可以通过 serviceManger 查询对应的 Binder 服务端, 这个查询的过程就是寻找服务端进程对应的在 binder 中的 “号码”, 这些号码由 servicemanager 统一管理, 那么 servicemanager 自己的号码注册为 0 号。</p><p>这好比网络传输中获取服务端的 ip 地址首先要通过 DNS 查询, 而这个 DNS 的 ip 地址都是已知的。</p><p>这里的就是 0 号, “号码”称为 handler</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre>
<span class="c1">// </span>
   <span class="k">if</span> <span class="p">(</span><span class="n">binder_become_context_manager</span><span class="p">(</span><span class="n">bs</span><span class="p">))</span> <span class="p">{</span>

        <span class="n">ALOGE</span><span class="p">(</span><span class="s">"cannot become context manager (%s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

<span class="kt">int</span> <span class="nf">binder_become_context_manager</span><span class="p">(</span><span class="k">struct</span> <span class="n">binder_state</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>

    <span class="k">return</span> <span class="n">ioctl</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">BINDER_SET_CONTEXT_MGR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="p">}</span>
<span class="c1">//调用到内核的 ioctl, 参数是 BINDER_SET_CONTEXT_MGR</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">binder_ioctl_set_ctx_mgr</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>

    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">binder_proc</span> <span class="o">*</span><span class="n">proc</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">binder_context</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="n">proc</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>

    <span class="c1">//新建一个节点 ，第二个参数是 0 </span>
    <span class="n">context</span><span class="o">-&gt;</span><span class="n">binder_context_mgr_node</span> <span class="o">=</span> <span class="n">binder_new_node</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> 
    
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">binder_node</span> <span class="o">*</span><span class="nf">binder_new_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span> 

    <span class="n">binder_uintptr_t</span> <span class="n">ptr</span><span class="p">,</span>
    <span class="n">binder_uintptr_t</span> <span class="n">cookie</span><span class="p">)</span>

<span class="p">{</span>

    <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">proc</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">binder_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

    <span class="c1">//插入这个节点</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">binder_node</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">node</span><span class="o">-&gt;</span><span class="n">proc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
    
    <span class="c1">//ptr 指的就是用户空间的一个引用，因此这个参数为 0</span>
    <span class="c1">//所以 serviceManger 在客户端的对应的 binder 对象就是 0 号引用获得的。</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>

<span class="p">}</span>

</pre></table></code></div></div><h3 id="二-servicemanager-binder-的获取">(二). ServiceManager Binder 的获取</h3><p>我们知道 ServiceManager 作为一个进程, 客户端于其的通信也是一种进程通信, 从上面可以知道 ServiceManager 对应的 Binder 是 0 号引用, 那么客户端是是如何获取的到 0 号引用即 ServiceManager 的 Binder 对象呢？</p><p>以 bindService 为例</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>
<span class="c1">//base\core\java\android\app\ContextImpl.java</span>
  <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">bindServiceCommon</span><span class="o">(</span><span class="nc">Intent</span> <span class="n">service</span><span class="o">,</span> <span class="nc">ServiceConnection</span> <span class="n">conn</span><span class="o">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">,</span> <span class="nc">Handler</span> <span class="n">handler</span><span class="o">,</span> <span class="nc">UserHandle</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
           <span class="o">...</span>
           <span class="c1">//bindService 是通过 ActivityManager.getService() 去调用的</span>
            <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="nc">ActivityManager</span><span class="o">.</span><span class="na">getService</span><span class="o">().</span><span class="na">bindService</span><span class="o">(</span>
                <span class="n">mMainThread</span><span class="o">.</span><span class="na">getApplicationThread</span><span class="o">(),</span> <span class="n">getActivityToken</span><span class="o">(),</span> <span class="n">service</span><span class="o">,</span>
                <span class="n">service</span><span class="o">.</span><span class="na">resolveTypeIfNeeded</span><span class="o">(</span><span class="n">getContentResolver</span><span class="o">()),</span>
                <span class="n">sd</span><span class="o">,</span> <span class="n">flags</span><span class="o">,</span> <span class="n">getOpPackageName</span><span class="o">(),</span> <span class="n">user</span><span class="o">.</span><span class="na">getIdentifier</span><span class="o">());</span>
           <span class="o">...</span>
    <span class="o">}</span>

</pre></table></code></div></div><p>在 ActivityManager 中</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre>
<span class="c1">//base\core\java\android\app\ActivityManager.java</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="nc">IActivityManager</span> <span class="nf">getService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">IActivityManagerSingleton</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Singleton</span><span class="o">&lt;</span><span class="nc">IActivityManager</span><span class="o">&gt;</span> <span class="nc">IActivityManagerSingleton</span> <span class="o">=</span>
        <span class="k">new</span> <span class="nc">Singleton</span><span class="o">&lt;</span><span class="nc">IActivityManager</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">protected</span> <span class="nc">IActivityManager</span> <span class="nf">create</span><span class="o">()</span> <span class="o">{</span>
            <span class="c1">//要获取 IActivityManager 对象,就要通过 ServiceManager 去查询并获取</span>
                <span class="kd">final</span> <span class="nc">IBinder</span> <span class="n">b</span> <span class="o">=</span> <span class="nc">ServiceManager</span><span class="o">.</span><span class="na">getService</span><span class="o">(</span><span class="nc">Context</span><span class="o">.</span><span class="na">ACTIVITY_SERVICE</span><span class="o">);</span>
                <span class="kd">final</span> <span class="nc">IActivityManager</span> <span class="n">am</span> <span class="o">=</span> <span class="nc">IActivityManager</span><span class="o">.</span><span class="na">Stub</span><span class="o">.</span><span class="na">asInterface</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">am</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">};</span>
<span class="c1">// base\core\java\android\os\ServiceManager.java</span>

<span class="c1">//通过一个 服务的名字去获取对应的 Binder </span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">IBinder</span> <span class="nf">getService</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
          <span class="nc">IBinder</span> <span class="n">service</span> <span class="o">=</span> <span class="n">sCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">service</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
              <span class="k">return</span> <span class="n">service</span><span class="o">;</span>
          <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
              <span class="c1">//这里就是先通过 getIServiceManager 去查询,再返回</span>
              <span class="k">return</span>
              <span class="nc">Binder</span><span class="o">.</span><span class="na">allowBlocking</span><span class="o">(</span><span class="n">getIServiceManager</span><span class="o">().</span><span class="na">getService</span><span class="o">(</span><span class="n">name</span><span class="o">));</span>
          <span class="o">}</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">RemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="nc">Log</span><span class="o">.</span><span class="na">e</span><span class="o">(</span><span class="no">TAG</span><span class="o">,</span> <span class="s">"error in getService"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
  <span class="o">}</span>
  
  
  <span class="c1">//获取 ServiceManager Binder 对象 IServiceManager 就在这个 方法里</span>
 <span class="kd">private</span> <span class="kd">static</span> <span class="nc">IServiceManager</span> <span class="nf">getIServiceManager</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">sServiceManager</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="n">sServiceManager</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="c1">// Find the service manager</span>
      <span class="c1">//关键是这里的 BinderInternal.getContextObject();</span>
      <span class="n">sServiceManager</span> <span class="o">=</span> <span class="nc">ServiceManagerNative</span>
              <span class="o">.</span><span class="na">asInterface</span><span class="o">(</span><span class="nc">Binder</span><span class="o">.</span><span class="na">allowBlocking</span><span class="o">(</span><span class="nc">BinderInternal</span><span class="o">.</span><span class="na">getContextObject</span><span class="o">()));</span>
      <span class="k">return</span> <span class="n">sServiceManager</span><span class="o">;</span>
  <span class="o">}</span>
<span class="c1">//显然对应的方法就在 BinderInternal.getContextObject();</span>

<span class="c1">//base\core\java\com\android\internal\os\BinderInternal.java</span>
 <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">native</span> <span class="nc">IBinder</span> <span class="nf">getContextObject</span><span class="o">();</span>

</pre></table></code></div></div><p>这是个 native 方法对应 c++ 实现如下</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">//base\core\jni\android_util_Binder.cpp</span>
<span class="k">static</span> <span class="n">jobject</span> <span class="nf">android_os_BinderInternal_getContextObject</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">clazz</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getContextObject</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">javaObjectForIBinder</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

<span class="p">}</span>

</pre></table></code></div></div><p>android_util_Binder 的作用就是将 c/c++ 的 Binder 对象转换为 java 层。 接着看 ProcessState 的 getContextObject 方法</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre>
<span class="c1">// native\native\libs\binder\ProcessState.cpp</span>
<span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">ProcessState</span><span class="o">::</span><span class="n">getContextObject</span><span class="p">(</span><span class="k">const</span> <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;&amp;</span> <span class="cm">/*caller*/</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">getStrongProxyForHandle</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//这个 0 就是之前说过的 ServiceManager 在 Binder 驱动中对应的引用号 hanler，这里就为 0 .即 ServiceManager 为 0 号。</span>

<span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">ProcessState</span><span class="o">::</span><span class="n">getStrongProxyForHandle</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">sp</span><span class="o">&lt;</span><span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    
    <span class="n">handle_entry</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="n">lookupHandleLocked</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="n">IBinder</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">binder</span><span class="p">;</span>
       <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">refs</span><span class="o">-&gt;</span><span class="n">attemptIncWeak</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
       
       <span class="c1">//当 handle == 0 的时候</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">handle</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//在 handle == 0 的情况下</span>
            <span class="c1">//因为 ServiceManager 唯一我们在创建其代理类的时候</span>
            <span class="c1">//不需要持有其引用的对象，因为其引用号已知为 0 </span>
            <span class="c1">//所以通过简单的远程访问确定其已经注册否则 </span>
            <span class="c1">//ServiceManager 就不能使用。</span>
                <span class="n">Parcel</span> <span class="n">data</span><span class="p">;</span>
                <span class="n">status_t</span> <span class="n">status</span> <span class="o">=</span> <span class="n">IPCThreadState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">transact</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">IBinder</span><span class="o">::</span><span class="n">PING_TRANSACTION</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">DEAD_OBJECT</span><span class="p">)</span>
                   <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>在说明 new BpBinder(handle) 的作用之前, 这里记录下一个疑问</p><p>ServiceManager 对应在 native 层的是 IServiceManager.cpp 但是从上面的调用链来看并没有涉及到, 可能是 c/c++ 的语法或者是有部分源码看漏了, 这里先借用其他文章的思路, 直接看 IServiceManager。</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">//native\native\libs\binder\IServiceManager.cpp</span>
<span class="n">sp</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span> <span class="n">defaultServiceManager</span><span class="p">()</span>
<span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">gDefaultServiceManager</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">gDefaultServiceManager</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="n">AutoMutex</span> <span class="n">_l</span><span class="p">(</span><span class="n">gDefaultServiceManagerLock</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">gDefaultServiceManager</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">gDefaultServiceManager</span> <span class="o">=</span> <span class="n">interface_cast</span><span class="o">&lt;</span><span class="n">IServiceManager</span><span class="o">&gt;</span><span class="p">(</span>
                <span class="n">ProcessState</span><span class="o">::</span><span class="n">self</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getContextObject</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">));</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">gDefaultServiceManager</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
                <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">gDefaultServiceManager</span><span class="p">;</span>

<span class="p">}</span>

</pre></table></code></div></div><p>这个获取 的过程可以参考 浅谈Android系统进程间通信（IPC）机制Binder中的Server和Client获得Service Manager接口之路</p><p>总结</p><p>一般跨进程的通信首先要需要通过 ServiceManager 获取对方的代理接口才能通信,但是 对于 ServiceManager 自己的代理接口的获取过程不需要跨进程,因为其引用号已知为 0.</p><p>如果是同一个进程的的通信,客户端 透过 Binder 驱动向 服务端 请求一个 Binder 代理对象时，Binder 驱动发现它们是同一个进程，就向 客户端 进程返回一个 Binder 本地对象，而不是 Binder 代理对象。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://yishengma.github.io/2019/01/24/Android-Binder%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/12404" alt="alt" /></p><h2 id="四通信">四.通信</h2><p>在客户端拿到 IServiceManager 的 Binder 对象后就将其封装成为一个 代理对象 Proxy</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>
<span class="c1">//base\core\java\android\os\ServiceManager.java</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="nc">IServiceManager</span> <span class="nf">getIServiceManager</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">sServiceManager</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">sServiceManager</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// Find the service manager</span>
        <span class="n">sServiceManager</span> <span class="o">=</span> <span class="nc">ServiceManagerNative</span>
                <span class="o">.</span><span class="na">asInterface</span><span class="o">(</span><span class="nc">Binder</span><span class="o">.</span><span class="na">allowBlocking</span><span class="o">(</span><span class="nc">BinderInternal</span><span class="o">.</span><span class="na">getContextObject</span><span class="o">()));</span>
        <span class="k">return</span> <span class="n">sServiceManager</span><span class="o">;</span>
    <span class="o">}</span>

</pre></table></code></div></div><p>下面具体看 ServiceManagerNative的asInterface</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">public</span> <span class="nc">IServiceManager</span> <span class="nf">asInterface</span><span class="o">(</span><span class="nc">IBinder</span> <span class="n">obj</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="nc">IServiceManager</span> <span class="n">in</span> <span class="o">=</span>
            <span class="o">(</span><span class="nc">IServiceManager</span><span class="o">)</span><span class="n">obj</span><span class="o">.</span><span class="na">queryLocalInterface</span><span class="o">(</span><span class="n">descriptor</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">in</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">in</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ServiceManagerProxy</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
    <span class="o">}</span>

</pre></table></code></div></div><p>这部分代码对于手动写过 Binder 客户端服务端的人都比较熟悉, 主要是判断获取的接口是位于同一进程还是 不同进程，如果是统一进程, 则不需要进行跨进程的通信, 所以返回本地接口/对象就像就行，如果是不同进程, 就返回一个代理对象, 下面看如何通过跨进程通信。</p><p>以向 SericeManager 获取服务为例</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre>
<span class="kd">class</span> <span class="nc">ServiceManagerProxy</span> <span class="kd">implements</span> <span class="nc">IServiceManager</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">ServiceManagerProxy</span><span class="o">(</span><span class="nc">IBinder</span> <span class="n">remote</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mRemote</span> <span class="o">=</span> <span class="n">remote</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">IBinder</span> <span class="nf">asBinder</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">mRemote</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">IBinder</span> <span class="nf">getService</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">RemoteException</span> <span class="o">{</span>
        <span class="nc">Parcel</span> <span class="n">data</span> <span class="o">=</span> <span class="nc">Parcel</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
        <span class="nc">Parcel</span> <span class="n">reply</span> <span class="o">=</span> <span class="nc">Parcel</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
        <span class="n">data</span><span class="o">.</span><span class="na">writeInterfaceToken</span><span class="o">(</span><span class="nc">IServiceManager</span><span class="o">.</span><span class="na">descriptor</span><span class="o">);</span>
        <span class="n">data</span><span class="o">.</span><span class="na">writeString</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
        <span class="n">mRemote</span><span class="o">.</span><span class="na">transact</span><span class="o">(</span><span class="no">GET_SERVICE_TRANSACTION</span><span class="o">,</span> <span class="n">data</span><span class="o">,</span> <span class="n">reply</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="nc">IBinder</span> <span class="n">binder</span> <span class="o">=</span> <span class="n">reply</span><span class="o">.</span><span class="na">readStrongBinder</span><span class="o">();</span>
        <span class="n">reply</span><span class="o">.</span><span class="na">recycle</span><span class="o">();</span>
        <span class="n">data</span><span class="o">.</span><span class="na">recycle</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">binder</span><span class="o">;</span>
    <span class="o">}</span>

</pre></table></code></div></div><p>下面就对 getService 的几个变量做一下说明</p><p>data , 向 SericeManager (服务端)传递的参数 上面 writeString 写入数据，writeInterfaceToken 写入接口标识</p><p>reply , SericeManager (服务端 ) 执行后的往 reply 写入返回值 mRemote.transact 进行跨进程传输，这个返回会阻塞于 Binder 线程池，因为要等待其 SericeManager (服务端) 返回</p><p>reply.readStrongBinder() 服务端返回后唤醒当前 Binder 线程, 读取查询后的 Binder 对象。</p><ol><li><p>Parcel</p><p>Parcel 是传递的数据的载体, 在 java 层和 native 都有对应的类。主要的传输过程都在 transact 函数中。</p><li><p>transact</p></ol><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>
<span class="c1">//base\core\jni\android_util_Binder.cpp</span>
<span class="k">static</span> <span class="n">jboolean</span> <span class="nf">android_os_BinderProxy_transact</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> 

        <span class="n">jint</span> <span class="n">code</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">dataObj</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">replyObj</span><span class="p">,</span> <span class="n">jint</span> <span class="n">flags</span><span class="p">)</span> <span class="c1">// throws RemoteException</span>

<span class="p">{</span>

    <span class="c1">//将 java 层的对应的 Parcel 对应到 native 层</span>
    <span class="n">Parcel</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="n">parcelForJavaObject</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">dataObj</span><span class="p">);</span>
    <span class="n">Parcel</span><span class="o">*</span> <span class="n">reply</span> <span class="o">=</span> <span class="n">parcelForJavaObject</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">replyObj</span><span class="p">);</span>

     <span class="c1">//获取native 层的Binder 对象</span>
    <span class="n">IBinder</span><span class="o">*</span> <span class="n">target</span> <span class="o">=</span> <span class="n">getBPNativeData</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mObject</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="c1">//调用 native 层的 Binder 的 方法</span>
    <span class="n">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">target</span><span class="o">-&gt;</span><span class="n">transact</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">reply</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    
    <span class="n">reply</span><span class="o">-&gt;</span><span class="n">print</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">JNI_FALSE</span><span class="p">;</span>

</pre></table></code></div></div><p>最后都会调用 Binder 驱动的 binder_transaction 方法。</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">binder_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="nc">binder_proc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span>
               <span class="k">struct</span> <span class="nc">binder_thread</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span>
               <span class="k">struct</span> <span class="nc">binder_transaction_data</span> <span class="o">*</span><span class="n">tr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reply</span><span class="p">){</span>
   
            <span class="c1">// 由 handle 找到相应 binder 引用, 由binder引用 找到相应 binder 节点</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">binder_get_ref</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">.</span><span class="n">handle</span><span class="p">);</span>
            <span class="n">target_node</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">target_node</span> <span class="o">=</span> <span class="n">binder_context_mgr_node</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 由 binder 节点 找到相应 binder proc 结构体</span>
        <span class="n">target_proc</span> <span class="o">=</span> <span class="n">target_node</span><span class="o">-&gt;</span><span class="n">proc</span><span class="p">;</span>
    <span class="err">}</span>

    <span class="c1">//从目标进程 proc 中分配内存空间</span>
    <span class="n">t</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">binder_alloc_buf</span><span class="p">(</span><span class="n">target_proc</span><span class="p">,</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">,</span>
        <span class="n">tr</span><span class="o">-&gt;</span><span class="n">offsets_size</span><span class="p">,</span> <span class="o">!</span><span class="n">reply</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">TF_ONE_WAY</span><span class="p">));</span>

    <span class="c1">//分别拷贝用户空间的 binder_transaction_data  到目标进程的 binder 缓冲区</span>
    <span class="n">copy_from_user</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
        <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">data_size</span><span class="p">);</span>
    <span class="n">copy_from_user</span><span class="p">(</span><span class="n">offp</span><span class="p">,</span>
        <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">tr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">ptr</span><span class="p">.</span><span class="n">offsets</span><span class="p">,</span> <span class="n">tr</span><span class="o">-&gt;</span><span class="n">offsets_size</span><span class="p">);</span>

   <span class="p">...</span>
    <span class="k">return</span><span class="p">;</span>
<span class="err">}</span>

</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://yishengma.github.io/2019/01/24/Android-Binder%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/12405" alt="alt" /></p><p>通过这种方式数据的传递就从 A 进程到了 Service 进程。</p><p>关于 Binder 的机制, 这里只是记录笔者的自己理一遍的思路，如果想要深入学习，可以参考一下博客，本篇也是参考其博客才写下的。</p><p><a href="http://gityuan.com/tags/#binder">Gityuan 的 Binder系列</a></p><p><a href="http://weishu.me/2016/01/12/binder-index-for-newer/">Binder学习指南</a></p><p><a href="https://blog.csdn.net/universus/article/details/6211589#t1">Android Bander设计与实现 - 设计篇</a></p><p><a href="https://blog.csdn.net/luoshengyang/article/details/6618363">一篇文章了解相见恨晚的 Android Binder 进程间通讯机制</a></p><p><a href="https://blog.csdn.net/luoshengyang/article/details/6618363">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a></p><p><a href="https://www.jianshu.com/p/4ee3fd07da14">图文详解 Android Binder跨进程通信的原理</a></p><p>摘自 <a href="https://yishengma.github.io/2019/01/24/Android-Binder%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BF%9B%E9%98%B6%E7%AF%87%EF%BC%89/">Anrodid Binder机制</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/android/'>Android</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/binder/" class="post-tag no-text-decoration" >Binder</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Anroid Binder机制 - Edwin Here&url=https://edwin1122.github.io/posts/Android-Binder/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Anroid Binder机制 - Edwin Here&u=https://edwin1122.github.io/posts/Android-Binder/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Anroid Binder机制 - Edwin Here&url=https://edwin1122.github.io/posts/Android-Binder/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Jekyll-is-really-cool/">Jekyll is really cool</a><li><a href="/posts/Android-Binder/">Anroid Binder机制</a><li><a href="/posts/constructor-vs-method/">Java constructor VS method</a><li><a href="/posts/Gradle/">Gradle 详解</a><li><a href="/posts/getting-started/">Getting Started</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/binder/">Binder</a> <a class="post-tag" href="/tags/constructor/">constructor</a> <a class="post-tag" href="/tags/factory/">Factory</a> <a class="post-tag" href="/tags/favicon/">favicon</a> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/google-analytics/">google analytics</a> <a class="post-tag" href="/tags/gradle/">Gradle</a> <a class="post-tag" href="/tags/jekyll/">Jekyll</a> <a class="post-tag" href="/tags/markdown/">Markdown</a> <a class="post-tag" href="/tags/pageviews/">pageviews</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Gradle/"><div class="card-body"> <span class="timeago small" > Mar 11, 2020 <i class="unloaded">2020-03-11T14:10:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Gradle 详解</h3><div class="text-muted small"><p> java开发中有两个大名鼎鼎的项目构建ANT、Maven。 Google推荐使用的Android Studio是采用Gradle来构建项目的。Gradle是一个非常先进的项目构建工具。 Gradle是用了一种基于Groovy的领域特定语言（DSL，Domain Specific Language）来声明项目设置，摒弃了XML（如ANT和Maven）的各种繁琐配置...</p></div></div></a></div><div class="card"> <a href="/posts/Markdown-align-center/"><div class="card-body"> <span class="timeago small" > Mar 11, 2021 <i class="unloaded">2021-03-11T15:11:41+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>How to align images in markdown</h3><div class="text-muted small"><p> Image alignment in markdown Normal markdown image tags don’t allow for any alignment properties and thats a bummer when you are trying to make your README.md file pretty on github. &lt;!-- No alig...</p></div></div></a></div><div class="card"> <a href="/posts/enable-google-pv/"><div class="card-body"> <span class="timeago small" > Jan 4, 2021 <i class="unloaded">2021-01-04T07:32:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Enable Google Page Views</h3><div class="text-muted small"><p> This post is to enable Page Views on the Chirpy theme based blog that you just built. This requires technical knowledge and it’s recommended to keep the google_analytics.pv disabled unless you have...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Markdown-align-center/" class="btn btn-outline-primary" prompt="Older"><p>How to align images in markdown</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/username">Edwin</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/binder/">Binder</a> <a class="post-tag" href="/tags/constructor/">constructor</a> <a class="post-tag" href="/tags/factory/">Factory</a> <a class="post-tag" href="/tags/favicon/">favicon</a> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/google-analytics/">google analytics</a> <a class="post-tag" href="/tags/gradle/">Gradle</a> <a class="post-tag" href="/tags/jekyll/">Jekyll</a> <a class="post-tag" href="/tags/markdown/">Markdown</a> <a class="post-tag" href="/tags/pageviews/">pageviews</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://Edwin1122.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
